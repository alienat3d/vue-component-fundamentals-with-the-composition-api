<!-- ? 4.15 Что интересно заметить, здесь мы также могли бы обойтись и без кастомного события и так код был бы даже лаконичнее, если мы использовали бы событие клика и передавали бы туда название плана, по которому кликнули (это решение представлено в версии без комментарием). Однако здесь мы ориентировались на рассмотрение использования кастомных событий, что и было продемонстрировано. -->
<script setup>
// import { ref } from 'vue'

// 4.13 Конечно, нам нужно указать проп "selected" и здесь.
const props = defineProps({
  name: { type: String, default: 'Default Plan' },
  selected: { type: Boolean, default: false },
})

// 4.2 Стоит также добавить локальные данные для CoffeePlan комп. для записи состояния, что он был выбран.
// 4.14.0 Теперь, когда у нас есть проп "selected" - можно избавится от этого рефа.
// const selected = ref(false)

// 4.5 Но нам также нужно, чтобы пользователь мог за раз выбрать лишь 1 план из всех, значит у других ref "selected" должен меняться на false, кроме того, на какой кликнули позже всех. И чтобы этого добиться нам нужно, чтобы родительский комп "PlanPicker" знал об этом. Сделать это можно при помощи кастомных событий, для этого используем специальный метод «defineEmits()». Можно создавать столько кастомных событий (далее - эмитов), сколько пожелаем.
// 4.7 А затем мы эмитируем кастомное событие "selected", чтобы у родительского комп. был к нему доступ. И теперь PlanPicker будет знать, когда по одному из его дочерних CoffeePlan комп. кликнули.
const emit = defineEmits(['selected'])

const selectPlan = () => {
  // 4.14.1 Также и эта строчка нам уже не нужна.
  // selected.value = !selected.value
  // 4.8 При эмитировании кастомного события вторым аргументом можно пересылать родительскому комп. т.н. "payload", например какие-то данные, с которыми он сможет работать дальше. Логично будет передавать название плана, т.ч. PlanPicker будет знать какой план в данный момент выбран пользователем (его мы получим из пропа).
  // Go to [src\components\PlanPicker.vue]
  emit('selected', props.name)
}
</script>
<template>
  <!-- 4.3 Также добавим "active-plan" CSS-класс, который будет делать зелёную подсветку выбранного плана. И мы будем добавлять его по условию, когда ref "selected" в положении true. -->
  <!-- 4.4 А ещё нужен слушатель по событию клик, который будет менять значение ref "selected" на противоположное. -->
  <!-- <div class="plan" :class="{ 'active-plan': selected }" @click="selected = !selected"> -->
  <!-- 4.6 Перенесём выражение в функцию "selectPlan", которую пропишем в секции "script". -->
  <div class="plan" :class="{ 'active-plan': selected }" @click="selectPlan">
    <div class="description">
      <span class="title">{{ name }} </span>
    </div>
  </div>
</template>
